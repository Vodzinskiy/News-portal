
# Тема: Веб-сайт розклад руху потягів
**Сутності**: потяги, станції, дата/час 

**Актори**: Користувач, Адміністратор 

**Сценарії використання**: 

+ ___Користувач___: Перегляд руху поїздів, Пошуг потягів з однієї заданої станції до іншої 

+ ___Адміністратор___: Створення/редагування/видалення інформації про потяги, станції 

## Виконали студенти групи ІО-04 
  - Водзінський Роман
  - Возниця Дмитро
  - Нерода Арсен
  

# Лаб 2

+ __Користувач__ може знайти потяг заповнивши форму, також може натиснути на потяг та переглянути всю інформацію про нього

+ __Адміністратор__ може створювати/редагувати/видаляти станції та потяги за id, а також для редагування потягів змінювати не тільки його назву, а й станції через які він ходить

Посилання на сайт: [train-schedule](https://train-schedule-spring.herokuapp.com/) (для користувача)

Посилання на сайт: [train-schedule](https://train-schedule-spring.herokuapp.com/admin) (для адміністратора)

## Контрольні питання 

1. Поясніть значення наступних термінів:

  - Inversion of Control (IoC) - це принцип у розробці програмного
  забезпечення, який передає керування об’єктами або частинами програми до
  контейнера або фреймворку. Найчастіше ми використовуємо його в контексті
  об'єктно-орієнтованого програмування. В нашому випадку управління бере Spring
  Framework.
  
  - IoC container - контейнер Spring IoC є ядром Spring Framework. Він створює об’єкти, конфігурує та
  збирає їхні залежності, керує всім їхнім життєвим циклом.
  
  - Dependency Injection (DI) - це фундаментальний аспект фреймворку Spring, за
  допомогою якого контейнер Spring «впроваджує» об’єкти в інші об’єкти або
  «залежності».
  
  - Dependency inversion principle - Принцип інверсії залежностей (DIP) є частиною колекції принципів об'єктно-орієнтованого програмування, широко відомих як SOLID.       Принцип інверсії залежностей (DIP) стверджує, що модулі високого рівня не повинні залежати від модулів низького рівня; обидва повинні залежати від абстракцій.         Абстракції не повинні залежати від деталей.

2.  В чому полягає різниця між анотаціями @Component та @Bean? Опишіть переваги та недоліки створення бінів за допомогою цих анотацій.

|@Bean|@Component|
|---|---|
|@Bean використовується для явного оголошення одного bean-компонента, замість того, щоб дозволити Spring зробити це автоматично |Якщо будь-який клас анотовано @Component, він буде автоматично виявлений за допомогою сканування шляху до класу|
|Bean можна створити, навіть якщо клас знаходиться поза контейнером spring|Ми не можемо створити Component, якщо клас знаходиться поза контейнером spring|
|Це анотація на рівні методу|Це анотація рівня класу|
|Працює лише тоді, коли клас анотовано @Configuration|Працює без анотації @Configuration|
|@bean використовується, якщо вам потрібна конкретна реалізація на основі динамічних умов|Для Component ми не можемо написати конкретну реалізацію на основі динамічних умов|

3. Чому слід уникати ін’єкцій залежностей напряму у поле біна?

Тому що таким образом ми фактично втрачаємо гнучкість нашого проекту.
Наприклад якщо ми захочемо переконфігурувати проект, нам прийдеться вручну
правити код що у великих проектах забирає багато часу. Також це порушує Explicit
Dependency Principle.

4.  В яких випадках краще використовувати ін’єкції залежностей за допомогою конструкторів, а в яких за допомогою сетерів?

Конструктори ми повинні використовувати в разі якщо нам потрібно створити об’єкт зразу з всіма залежностями, в той час як сетери ми повинні використовувати коли ми
працюємо з великою кількістю залежностей а також це добре для читабельності.

5. В яких випадках краще використовувати біни типу singleton, а в яких prototype?

Біни singleton ми використовуємо для stateless об’єктів (без стану), тобто таких де ми можемо створити тільки один їхній екземпляр. В той час як prototype
використовується для бінів з багатьма станами.

6. Чи можливе у Spring Framework створення циркулярних залежностей при ін’єкціях?

Зараз Spring Framework не підтримує циркулярних залежностей. Це робить код набагато важчим для підтримування, читання, тестування та вразливішим до
помилок.

7. Чи може бути в одному проекті кілька класів з реалізацією якогось інтерфейсу, якщо цей інтерфейс використовується для ін’єкції залежностей?

Так

8. Чи може бін мати кілька методів, помічених анотацією @Autowired?

Так, це працює добре з сетерами.

9. Чи може бін мати кілька конструкторів, помічених анотацією @Autowired?

Так
